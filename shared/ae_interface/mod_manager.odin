package ae_interface

import "core:mem"
import aec "shared:ae_common"
import doc "shared:ae_common/doc_utils"

// The Mod Manager is a singleton that handles both mod (see 
// `ae_common/mod.odin`) and mod loader (see `Mod_Loader`) initialization.
// Note that the user can directly register and remove mod loaders, but mod 
// loadings and unloadings will be queued up and will be applied by the engine
// in the most opportune moment.
// Please note that mod loader and mod removals are discouraged and should be
// avoided.
// For the implementation documentation, see `ae_common\mod_manager.odin`
// @singleton
// @lifetime: Mod_Manager is valid for the entire application lifetime
// @thread_safety: Mod_Manager is thread safe
Mod_Manager :: doc.Singleton_Symbol

// A Mod Loader is a loader for a specific class of file types. In order to be
// valid, a Mod_Loader must implement the `Mod_Loader_ITable`.
// By default, the engine contains mod loaders for the following types:
//   - directories + zip, aemod files: can define behavoiur by configuration,
//                                     types and, optionally by code (via shared
//                                     libraries)
//   - dll, so, dylib: depending from the operating system, these mods define
//                     behavoiur by code
// For futher implementation dectails, see `ae_common\mod_loader.odin`
// TODO(Vicix): Expand The documentation of common mod loaders
// @lifetime: valid from registration until removal from the mod manager. Please
//            note that the user cannot directly interact with the mod loader.
// @thread_safety: Every mod loader must be designed to be thread safe. However
//                 note that this is mod loader implementation dependant. The
//                 default mod loaders are garanteed to be safe.
Mod_Loader :: aec.Mod_Loader

// Mod_Loader_ITable is a interface table that every Mod Loader must implement.
// For implementation details, see `ae_common:Mod_Loader_Itable`, 
// `ae_common\mod_loader.odin` and related procedures
Mod_Loader_ITable :: aec.Mod_Loader_ITable

// The Mod_Loader_Id is a unique identifier for a mod loader. It will be 
// assigned upon mod loader registration
Mod_Loader_Id :: aec.Mod_Loader_Id

// Mod_Info contains the general informations of a mod. It is generated by a
// mod loader.
// @lifetime: valid from the queued mod load, up to the queued mod unload
Mod_Info :: aec.Mod_Info

// The Mod_Id is a unique identifier for a mod. It will be assigned upon mod 
// queued loading
Mod_Id :: aec.Mod_Id

// See `ae_common:Mod_Load_Error`
Mod_Load_Error :: aec.Mod_Load_Error

// A Mod proc table is a way for mods to communicate between them. 
// For example, if a mod defines an api, it can export his public procedures in 
// an internal table and handle a pointer to that table to the mod loader. 
// Another mod will then be able to request that pointer and (upon 
// interpretation) call the first mod's public procedures.
Mod_ProcTable :: doc.Documentation_Symbol

INVALID_MODID :: aec.INVALID_MODID
INVALID_MODLOADERID :: aec.INVALID_MODLOADERID

modmanager_register_modloader :: #force_inline proc(mod_loader: Mod_Loader) -> Mod_Loader_Id {
	return AE_MOD_PROC_TABLE.modmanager_register_modloader(mod_loader)
}

modmanager_remove_modloader :: #force_inline proc(modloader_identifier: Mod_Loader_Id) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_remove_modloader(modloader_identifier)
}

modmanager_get_modloaderid :: #force_inline proc(loader_name: string) -> aec.Mod_Loader_Id {
	return AE_MOD_PROC_TABLE.modmanager_get_modloaderid(loader_name)
}

modmanager_get_modloaderid_for_file :: #force_inline proc(file_path: string) -> aec.Mod_Loader_Id {
	return AE_MOD_PROC_TABLE.modmanager_get_modloaderid_for_file(file_path)
}

modmanager_is_modloaderid_valid :: #force_inline proc(loader_id: aec.Mod_Loader_Id) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_is_modloaderid_valid(loader_id)
}

modmanager_can_load_file :: #force_inline proc(file_path: string) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_can_load_file(file_path)
}

modmanager_queue_load_mod :: #force_inline proc(
	mod_path: string,
) -> (
	aec.Mod_Load_Error,
	aec.Mod_Id,
) {
	return AE_MOD_PROC_TABLE.modmanager_queue_load_mod(mod_path)
}

modmanager_queue_load_folder :: #force_inline proc(folder_path: string) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_queue_load_folder(folder_path)
}

modmanager_queue_unload_mod :: #force_inline proc(mod_id: aec.Mod_Id) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_queue_unload_mod(mod_id)
}

modmanager_force_load_queued_mods :: #force_inline proc() -> bool {
	return AE_MOD_PROC_TABLE.modmanager_force_load_queued_mods()
}

modmanager_get_mod_proctable :: #force_inline proc(mod_id: aec.Mod_Id) -> rawptr {
	return AE_MOD_PROC_TABLE.modmanager_get_mod_proctable(mod_id)
}

modmanager_get_modinfo :: #force_inline proc(mod_id: aec.Mod_Id) -> (aec.Mod_Info, bool) {
	return AE_MOD_PROC_TABLE.modmanager_get_modinfo(mod_id)
}

modmanager_get_modid_from_name :: #force_inline proc(mod_name: string) -> aec.Mod_Id {
	return AE_MOD_PROC_TABLE.modmanager_get_modid_from_name(mod_name)
}

modmanager_get_modid_from_path :: #force_inline proc(mod_path: string) -> aec.Mod_Id {
	return AE_MOD_PROC_TABLE.modmanager_get_modid_from_path(mod_path)
}

modmanager_is_modid_valid :: #force_inline proc(mod_id: aec.Mod_Id) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_is_modid_valid(mod_id)
}

modmanager_is_modid_loaded :: #force_inline proc(mod_id: aec.Mod_Id) -> bool {
	return AE_MOD_PROC_TABLE.modmanager_is_modid_loaded(mod_id)
}

modmanager_get_modinfo_list :: #force_inline proc(allocator: mem.Allocator) -> []Mod_Info {
	return AE_MOD_PROC_TABLE.modmanager_get_modinfo_list(allocator)
}

