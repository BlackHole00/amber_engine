package amber_engine_scheduler_utils

import "base:runtime"
import "core:log"
import "core:mem"

// Generally Odin's printing procedures take a lot of (stack) memory. A simple
// print procedure with a non struct parameter takes around 14 kilobytes of 
// stack. If we are below that we issue a warning. 24 kilobytes are just a nice
// wiggle room.
// TODO(Vicix): This system to check for stack overflow is really bad, since 
//              the program might crash without any warnings. In a normal 
//              program when a normal stack overflow occurs, at least it is 
//              possible to see the crash reason with a debugger. However with
//              this custom stack implementation a generic access violation
//              is generated
STACK_USAGE_THRESHOLD :: 24 * mem.Kilobyte

MINIMUM_SAFE_STACK_SIZE :: 256 * mem.Kilobyte

DEFAULT_STACK_SIZE :: 2 * mem.Megabyte

// The Procedure_Context contains all the data necessary to save the procedure
// caller data and the procedure (callee) data (both register and stack space).
// @sources: _Register_Snapshot is architecture dependent 
Procedure_Context :: struct {
	caller_registers: _Register_Snapshot,
	callee_registers: _Register_Snapshot,
	callee_stack:     Procedure_Stack,
}

// Frees a Procedure_Context. Generated by the call() procedure
// @safety: Do *not* call if the corresponding procedure is being executed with 
//          this specific Procedure_Context. Freeing a context while it is being 
//          executed will result in a certain crash.
// @sources: _procedurecontext_free is os dependent
procedurecontext_free :: #force_inline proc(procedure_context: ^Procedure_Context) {
	_procedurecontext_free(procedure_context)
}

// Calls a procedure and initializes the provided Procedure_Context. The 
// target procedure will then be able to call the yield() and force_return()
// procedures and will be able to be resumed by the caller
// @parameters: procedure_address = a pointer to a procedure of exactly the type
//                                      proc(ptr: any pointer)
//                                  The procedure must not have any other 
//                                  parameters and must not return any value.The
//                                  procedure may use the context and use 
//                                  deferred statements
// @safety: Do *not* call if another call has been already issued. To resume the
//          target procedure after a yield() call please use the resume() 
//          procedures
// @memory_safety: The user should free the Procedure_Context using the 
//                 procedurecontext_free() procedure
// @sources: _call is os dependent
call :: #force_inline proc(
	procedure_context: ^Procedure_Context,
	procedure_address: rawptr,
	procedure_parameter: rawptr,
	procedure_context_parameter: ^runtime.Context,
	stack_size: uint = DEFAULT_STACK_SIZE,
	location := #caller_location,
) {
	if stack_size < 2 * MINIMUM_SAFE_STACK_SIZE {
		log.warnf(
			"A procedure is being called with a low stack size (%d bytes). Consider using *at least* %d bytes",
			stack_size,
			MINIMUM_SAFE_STACK_SIZE,
			location = location,
		)
	}

	_call(
		procedure_context,
		procedure_address,
		procedure_parameter,
		procedure_context_parameter,
		stack_size,
	)
}

// Yields a procedure (and thus returns the execution to the caller while 
// hibernating the procedure's state)
// @sources: - _yield is architecture dependent
//           - _get_stack_pointer is architecture dependent
yield :: #force_inline proc(procedure_context: ^Procedure_Context) {
	bytes_remaining := _get_stack_pointer() - procedure_context.callee_stack.stack_address
	if _get_stack_pointer() < procedure_context.callee_stack.stack_address {
		log.panicf("Stack overflow in Procedure_Context %x", (uintptr)(procedure_context))
	} else if bytes_remaining < STACK_USAGE_THRESHOLD {
		log.warnf(
			"The Procedure_Context %x is about to stack overflow. Only %d bytes remaining",
			(uintptr)(procedure_context),
			bytes_remaining,
		)
	}

	_yield(procedure_context)
}

// Resumes the execution of a previously hibernated (yielded) procedure.
// @safety: Do *not* call on a Procedure_Context of a terminated procedure, on
//          an Procedure_Context before the calling the call() procedure or on a
//          currently executing Procedure_Context
// @sources: _resume is architecture dependent
resume :: #force_inline proc(procedure_context: ^Procedure_Context) {
	_resume(procedure_context)
}

// Forces the return of a procedure (and thus returning the execution the the
// caller). 
// @note: This procedure is the same of a return statement, so it will not be
//        possible to resume it.
//        Since force_return is a diverging procedure it will make defer 
//        statements error
// @sources: - _force_return is architecture dependent
//           - _get_stack_pointer is architecture dependent
force_return :: #force_inline proc(procedure_context: ^Procedure_Context) -> ! {
	bytes_remaining := _get_stack_pointer() - procedure_context.callee_stack.stack_address
	if _get_stack_pointer() < procedure_context.callee_stack.stack_address {
		log.panicf("Stack overflow in Procedure_Context %x", (uintptr)(procedure_context))
	} else if bytes_remaining < STACK_USAGE_THRESHOLD {
		log.warnf(
			"The Procedure_Context %x is about to stack overflow. Only %d bytes remaining",
			(uintptr)(procedure_context),
			bytes_remaining,
		)
	}

	_force_return(procedure_context)
}

// The Procedure_Stack represents a stack of a procedure. A dedicated stack is 
// allocated for every procedure to make the context switch faster. The stack,
// depending on the implementation, is implemented using virtual memory. This 
// makes possible to have a large number of procedures suspended at a relatively
// low memory cost
@(private)
Procedure_Stack :: struct {
	stack_address: uintptr,
	stack_size:    uintptr,
	stack_base:    uintptr,
}

